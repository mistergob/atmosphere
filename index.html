<!--
PLAN (pseudocode)
- Add a native <input type="color" id="colorPicker"> inside the context menu.
- When opening the menu, sync the picker with the selected node's color.
- On picker change/input, apply the color to the current node and persist state.
- Replace prompt-based color change: clicking "Modifier la couleur" focuses/triggers the color input.
- Store colors as normalized HEX (#RRGGBB) in localStorage; convert from computed rgb() when needed.
- When creating/restoring nodes, use HEX values to avoid rgb()/var() mismatches.
- Auto-fit label font-size so text stays inside circles (binary search), run on create/rename/restore/reset/resize.
- Add font controls in context menu: family select, max size, and style toggles (bold/italic/underline). Persist per node.
-->

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Espace de Travail ‚Äî saisie hex</title>
  <style>
    :root {
      --bg: #f5f6f8;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #cc0000;
      --ring: rgba(17,24,39,0.08);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      user-select: none;
      overflow: hidden;
    }

    /* Stage */
    .stage { position: relative; width: 100vw; height: 100vh; display: grid; place-items: center; }

    /* Lines canvas */
    svg#wires { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    /* Node (circle) */
    .node {
      position: absolute; width: 110px; height: 110px; border-radius: 9999px;
      background-color: var(--primary);
      color: #fff; display: flex; align-items: center; justify-content: center;
      font-weight: 700; text-align: center; padding: 10px; box-shadow: 0 8px 24px var(--ring);
      cursor: grab; transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease; will-change: transform, left, top;
    }
    .node:active { cursor: grabbing; }
    .node:hover { filter: brightness(1.05); }
    .node .label { pointer-events: none; line-height: 1.1; width: 100%; max-width: 100%; overflow: hidden; word-break: break-word; hyphens: auto; }

    /* Context menu */
    .menu {
      position: fixed; display: none; flex-direction: column; min-width: 260px;
      background: var(--card); border: 1px solid #e5e7eb; border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15); overflow: hidden; z-index: 50;
    }
    .menu button { appearance: none; background: transparent; border: 0; text-align: left; padding: 12px 14px; font-size: 14px; cursor: pointer; }
    .menu button:hover { background: #f3f4f6; }
    .menu .row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-top: 1px solid #e5e7eb; }
    .menu .row label { font-size: 12px; color: var(--muted); }
    .menu .row input[type="color"] { width: 36px; height: 28px; border: 1px solid #e5e7eb; border-radius: 6px; padding: 0; background: transparent; cursor: pointer; }
    .menu select, .menu input[type="number"] { height: 28px; border: 1px solid #e5e7eb; border-radius: 6px; padding: 0 8px; background: transparent; }
    .menu .toggle-group { display: flex; gap: 8px; }
    .menu .toggle { padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; }
    .menu .toggle[aria-pressed="true"] { background: #111827; color: #fff; }

    /* Toolbar */
    .toolbar { position: fixed; right: 16px; top: 16px; display: flex; gap: 8px; background: var(--card); border: 1px solid #e5e7eb; border-radius: 14px; padding: 8px; box-shadow: 0 8px 24px var(--ring); z-index: 60; }
    .toolbar button { padding: 8px 12px; border: 0; border-radius: 10px; background: #111827; color: #fff; font-weight: 600; cursor: pointer; }
    .toolbar button.secondary { background: #4b5563; }
    .toolbar button.danger { background: #b91c1c; }

    /* Accessibility focus */
    .menu button:focus, .toolbar button:focus { outline: 3px solid #93c5fd; outline-offset: 2px; }
  </style>
</head>
<body>
  <div id="stage" class="stage" aria-label="Espace de travail">
    <svg id="wires" aria-hidden="true"></svg>
    <div id="main-node" class="node" data-id="node-0" style="left: calc(50% - 55px); top: calc(50% - 55px);">
      <span class="label">Cercle principal</span>
    </div>
  </div>

  <!-- Context menu -->
  <div id="menu" class="menu" role="menu" aria-hidden="true">
    <button data-action="add">‚ûï Cercle principal</button>
    <button data-action="addSmall">‚ûï Cercle secondaire</button>
    <button data-action="color">üé® Modifier la couleur</button>
    <div class="row" aria-label="S√©lecteur de couleur">
      <label for="colorPicker">Couleur</label>
      <input id="colorPicker" type="color" value="#CC0000" />
    </div>
    <div class="row" aria-label="Police">
      <label for="fontSelect">Police</label>
      <select id="fontSelect">
        <option value="system-ui">Syst√®me</option>
        <option value="Arial">Arial</option>
        <option value="Roboto">Roboto</option>
        <option value="Georgia">Georgia</option>
        <option value="'Times New Roman'">Times New Roman</option>
        <option value="'Courier New'">Courier New</option>
      </select>
    </div>
    <div class="row" aria-label="Taille de police">
      <label for="fontSizeMax">Taille max</label>
      <input id="fontSizeMax" type="number" min="6" max="72" step="1" value="32" />
    </div>
    <div class="row" aria-label="Style de texte">
      <label>Style</label>
      <div class="toggle-group">
        <button type="button" id="boldBtn" class="toggle" aria-pressed="true">Gras</button>
        <button type="button" id="italicBtn" class="toggle" aria-pressed="false">Italique</button>
        <button type="button" id="underlineBtn" class="toggle" aria-pressed="false">Soulign√©</button>
      </div>
    </div>
    <button data-action="rename">‚úèÔ∏è Renommer le cercle</button>
    <button data-action="delete">üóëÔ∏è Supprimer le cercle</button>
  </div>

  <!-- Quick actions -->
  <div class="toolbar" aria-label="Actions rapides">
    <button id="exportBtn">Exporter JSON</button>
    <button id="importBtn" class="secondary">Importer JSON</button>
    <button id="resetBtn" class="danger">R√©initialiser</button>
    <input id="fileInput" type="file" accept="application/json" style="display:none" />
  </div>

  <script>
    // --- State & Elements
    const stage = document.getElementById('stage');
    const svg = document.getElementById('wires');
    const menu = document.getElementById('menu');
    const mainNode = document.getElementById('main-node');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const colorPicker = document.getElementById('colorPicker');
    const fontSelect = document.getElementById('fontSelect');
    const fontSizeMax = document.getElementById('fontSizeMax');
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    const underlineBtn = document.getElementById('underlineBtn');

    let currentNode = null;
    let idCounter = 1; // will be overridden by saved state if any

    // Tailles fixes pour deux types de cercles
    const BIG_SIZE = 110;  // Cercle principal
    const SMALL_SIZE = 55; // Cercle secondaire

    // --- Utilities
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const isHex = (s) => !!String(s).match(/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/);

    function stageRect() { return stage.getBoundingClientRect(); }

    function getCenter(el) {
      const r = el.getBoundingClientRect();
      const s = stageRect();
      return { x: r.left - s.left + r.width / 2, y: r.top - s.top + r.height / 2 };
    }

    function qLines() { return svg.querySelectorAll('line'); }

    function updateLineEnds(line) {
      const from = document.querySelector(`[data-id="${line.dataset.from}"]`);
      const to = document.querySelector(`[data-id="${line.dataset.to}"]`);
      if (!from || !to) return;
      const c1 = getCenter(from);
      const c2 = getCenter(to);
      line.setAttribute('x1', c1.x); line.setAttribute('y1', c1.y);
      line.setAttribute('x2', c2.x); line.setAttribute('y2', c2.y);
    }

    function updateLinesFor(el) {
      const id = el.dataset.id;
      qLines().forEach(line => {
        if (line.dataset.from === id || line.dataset.to === id) updateLineEnds(line);
      });
    }

    function updateAllLines() { qLines().forEach(updateLineEnds); }

    function createLine(fromEl, toEl) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('stroke', '#111827');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-linecap', 'round');
      line.dataset.from = fromEl.dataset.id;
      line.dataset.to = toEl.dataset.id;
      svg.appendChild(line);
      updateLineEnds(line);
      return line;
    }

    // --- Text autosize helpers ---
    function fitLabelToNode(node) {
      const label = node.querySelector('.label');
      if (!label) return;
      // ensure measurement constraints
      label.style.width = '100%';
      label.style.maxWidth = '100%';
      label.style.whiteSpace = 'normal';
      label.style.overflow = 'hidden';
      label.style.wordBreak = 'break-word';

      const cs = getComputedStyle(node);
      const padX = (parseFloat(cs.paddingLeft) || 0) + (parseFloat(cs.paddingRight) || 0);
      const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
      const contentW = Math.max(0, node.clientWidth - padX);
      const contentH = Math.max(0, node.clientHeight - padY);

      const cap = parseFloat(node.dataset.maxFont);
      let low = 6; // min readable
      let high = Math.max(6, Math.floor(Math.min(contentH, Number.isFinite(cap) ? cap : contentH)));
      let best = low;

      // quick guard for empty
      if (!label.textContent || !label.textContent.trim()) {
        label.style.fontSize = Math.min(16, high) + 'px';
        return;
      }

      // binary search for largest font that fits both width and height
      for (let i = 0; i < 12 && low <= high; i++) { // 12 iterations are enough
        const mid = Math.floor((low + high) / 2);
        label.style.fontSize = mid + 'px';
        const fits = label.scrollWidth <= contentW && label.scrollHeight <= contentH;
        if (fits) { best = mid; low = mid + 1; } else { high = mid - 1; }
      }
      label.style.fontSize = best + 'px';
    }

    function fitAllLabels() {
      document.querySelectorAll('.node').forEach(fitLabelToNode);
    }

    function enableDrag(node) {
      if (node._dragEnabled) return; // avoid duplicate listeners
      let offsetX = 0, offsetY = 0;

      node.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return; // only left click
        currentNode = node;
        openMenu(null); // ensure menu closes while dragging
        node.setPointerCapture(e.pointerId);
        const rect = node.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        const onMove = (ev) => {
          const sr = stageRect();
          const newLeft = clamp(ev.clientX - sr.left - offsetX, 0, sr.width - rect.width);
          const newTop  = clamp(ev.clientY - sr.top - offsetY, 0, sr.height - rect.height);
          node.style.left = newLeft + 'px';
          node.style.top = newTop + 'px';
          updateLinesFor(node);
        };

        const onUp = () => {
          node.releasePointerCapture(e.pointerId);
          node.removeEventListener('pointermove', onMove);
          node.removeEventListener('pointerup', onUp);
          saveState();
        };

        node.addEventListener('pointermove', onMove);
        node.addEventListener('pointerup', onUp);
      });

      // Open custom menu on right-click + left-click
      node.addEventListener('contextmenu', (e) => { e.preventDefault(); openMenu(e, node); });
      
      node._dragEnabled = true;
    }

    function addNodeNear(target) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();

      const baseW = BIG_SIZE;
      const baseH = BIG_SIZE;

      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - baseW);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - baseH);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = baseW + 'px';
      node.style.height = baseH + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Cercle principal';
      node.appendChild(span);
      fitLabelToNode(node);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      saveState();
      return node;
    }

    function addNodeNearScaled(target, scale = 0.5) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();
      const baseW = parseFloat(getComputedStyle(target).width) || target.offsetWidth || 110;
      const baseH = parseFloat(getComputedStyle(target).height) || target.offsetHeight || 110;
      const w = SMALL_SIZE;
      const h = SMALL_SIZE;

      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - w);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - h);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = w + 'px';
      node.style.height = h + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Cercle secondaire';
      node.appendChild(span);
      fitLabelToNode(node);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      saveState();
      return node;
    }

    function openMenu(event, node) {
      // Close if called with null
      if (!event) { menu.style.display = 'none'; return; }
      currentNode = node || currentNode;
      if (!currentNode) return;
      menu.style.display = 'flex';
      menu.setAttribute('aria-hidden', 'false');

      // sync color picker with the current node color
      const initialHex = toHex(getComputedStyle(currentNode).backgroundColor) || '#CC0000';
      colorPicker.value = initialHex;

      // sync font family
      const labelEl = currentNode.querySelector('.label');
      const famInline = labelEl.style.fontFamily;
      const famOpt = famInline && Array.from(fontSelect.options).some(o => o.value === famInline) ? famInline : 'system-ui';
      fontSelect.value = famOpt;

      // sync max font size cap
      fontSizeMax.value = currentNode.dataset.maxFont || '32';

      // sync style toggles
      const csLabel = getComputedStyle(labelEl);
      const fw = parseInt(csLabel.fontWeight, 10);
      const isBold = (fw >= 600) || csLabel.fontWeight === 'bold';
      const isItalic = csLabel.fontStyle === 'italic';
      const isUnderline = (csLabel.textDecorationLine || csLabel.textDecoration || '').includes('underline');
      boldBtn.setAttribute('aria-pressed', isBold ? 'true' : 'false');
      italicBtn.setAttribute('aria-pressed', isItalic ? 'true' : 'false');
      underlineBtn.setAttribute('aria-pressed', isUnderline ? 'true' : 'false');

      const mRect = menu.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      const x = Math.min(event.clientX, vw - mRect.width - 8);
      const y = Math.min(event.clientY, vh - mRect.height - 8);
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      event.stopPropagation();
    }

    function closeMenu() {
      menu.style.display = 'none';
      menu.setAttribute('aria-hidden', 'true');
    }

    // Menu actions
    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.dataset.action;
      if (!currentNode) return;

      if (action === 'add') {
        addNodeNear(currentNode);
        closeMenu();
        return;
      }
      else if (action === 'addSmall') {
        addNodeNearScaled(currentNode, 0.5);
        const lbl = currentNode.querySelector('.label');
        if (lbl) lbl.textContent = 'Cercle principal';
        closeMenu();
        return;
      }
      else if (action === 'color') {
        // Focus & open the native color picker
        colorPicker.focus();
        colorPicker.click();
        return; // keep menu open while picking
      }
      
      else if (action === 'rename') {
        const label = currentNode.querySelector('.label');
        const name = prompt('Entrez un nouveau nom :', label.textContent.trim());
        if (name) { label.textContent = name; fitLabelToNode(currentNode); saveState(); }
        closeMenu();
        return;
      }
      else if (action === 'delete') {
        if (currentNode.id === 'main-node' || currentNode.dataset.id === 'node-0') {
          alert('Le cercle principal ne peut pas √™tre supprim√©.');
        } else {
          qLines().forEach(line => {
            if (line.dataset.from === currentNode.dataset.id || line.dataset.to === currentNode.dataset.id) line.remove();
          });
          currentNode.remove();
          saveState();
        }
        closeMenu();
        return;
      }
    });

    // Color picker live update
    colorPicker.addEventListener('input', (e) => {
      if (!currentNode) return;
      const hex = normalizeHex(e.target.value);
      if (!hex) return;
      currentNode.style.backgroundColor = hex;
      saveState(); // persist as you pick
    });

    // Font family
    fontSelect?.addEventListener('change', (e) => {
      if (!currentNode) return;
      const label = currentNode.querySelector('.label');
      label.style.fontFamily = e.target.value;
      fitLabelToNode(currentNode);
      saveState();
    });

    // Max font size cap
    fontSizeMax?.addEventListener('input', (e) => {
      if (!currentNode) return;
      const v = parseFloat(e.target.value);
      if (!Number.isFinite(v)) return;
      const min = parseFloat(e.target.min) || 6;
      const max = parseFloat(e.target.max) || 72;
      const clamped = Math.max(min, Math.min(max, v));
      currentNode.dataset.maxFont = String(clamped);
      fitLabelToNode(currentNode);
      saveState();
    });

    // Style toggles
    const togglePressed = (btn) => btn.setAttribute('aria-pressed', btn.getAttribute('aria-pressed') === 'true' ? 'false' : 'true');

    boldBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!currentNode) return;
      togglePressed(boldBtn);
      const on = boldBtn.getAttribute('aria-pressed') === 'true';
      const label = currentNode.querySelector('.label');
      label.style.fontWeight = on ? '700' : '400';
      fitLabelToNode(currentNode);
      saveState();
    });

    italicBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!currentNode) return;
      togglePressed(italicBtn);
      const on = italicBtn.getAttribute('aria-pressed') === 'true';
      const label = currentNode.querySelector('.label');
      label.style.fontStyle = on ? 'italic' : 'normal';
      fitLabelToNode(currentNode);
      saveState();
    });

    underlineBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!currentNode) return;
      togglePressed(underlineBtn);
      const on = underlineBtn.getAttribute('aria-pressed') === 'true';
      const label = currentNode.querySelector('.label');
      label.style.textDecoration = on ? 'underline' : 'none';
      fitLabelToNode(currentNode);
      saveState();
    });

    // Toolbar actions
    exportBtn.addEventListener('click', () => {
      const data = buildState();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'workspace.json'; a.click();
      URL.revokeObjectURL(url);
    });

    importBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const json = JSON.parse(text);
        restoreState(json);
      } catch (err) {
        alert('Fichier invalide.');
      } finally {
        fileInput.value = '';
      }
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('R√©initialiser l\'espace de travail ?')) {
        localStorage.removeItem('workspaceState');
        // Clear lines and nodes (except main)
        qLines().forEach(l => l.remove());
        stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });
        mainNode.style.left = 'calc(50% - 55px)';
        mainNode.style.top = 'calc(50% - 55px)';
        mainNode.querySelector('.label').textContent = 'Cercle principal';
        fitLabelToNode(mainNode);
        mainNode.style.backgroundColor = 'var(--primary)';
        idCounter = 1;
        saveState();
        updateAllLines();
      }
    });

    // Click outside to close menu
    document.addEventListener('click', (e) => {
      if (!menu.contains(e.target)) closeMenu();
    });

    // Keep lines aligned on resize
    window.addEventListener('resize', () => { updateAllLines(); fitAllLabels(); });

    // --- Color helpers ---
    function normalizeHex(input) {
      if (!input) return null;
      let m = String(input).match(/^#?([0-9a-fA-F]{6})$/);
      if (m) return '#' + m[1].toUpperCase();
      m = String(input).match(/^#?([0-9a-fA-F]{3})$/);
      if (m) return '#' + m[1].split('').map(c => (c + c)).join('').toUpperCase();
      return null;
    }

    function toHex(input) {
      if (!input) return null;
      const hexMatch = String(input).trim().match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
      if (hexMatch) {
        const hex = hexMatch[1];
        if (hex.length === 3) return '#' + hex.split('').map(c => c + c).join('').toUpperCase();
        return '#' + hex.toUpperCase();
      }
      const m = String(input).match(/rgba?\(\s*([0-9.]+)[,\s]+([0-9.]+)[,\s]+([0-9.]+)/i);
      if (!m) return null;
      const [r,g,b] = [m[1], m[2], m[3]].map(v => Math.max(0, Math.min(255, Math.round(parseFloat(v)))));
      return '#' + [r,g,b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    // Persistence
    function buildState() {
      const nodes = Array.from(stage.querySelectorAll('.node')).map(n => ({
        id: n.dataset.id,
        left: n.style.left || '0px',
        top: n.style.top || '0px',
        w: parseFloat(getComputedStyle(n).width) || 110,
        h: parseFloat(getComputedStyle(n).height) || 110,
        text: n.querySelector('.label')?.textContent || '',
        color: toHex(n.style.backgroundColor || getComputedStyle(n).backgroundColor) || '#CC0000',
        fontFamily: n.querySelector('.label')?.style.fontFamily || '',
        fontWeight: n.querySelector('.label')?.style.fontWeight || '',
        fontStyle: n.querySelector('.label')?.style.fontStyle || '',
        textDecoration: n.querySelector('.label')?.style.textDecoration || '',
        maxFont: n.dataset.maxFont ? parseFloat(n.dataset.maxFont) : null
      }));
      const edges = Array.from(qLines()).map(l => ({ from: l.dataset.from, to: l.dataset.to }));
      return { idCounter, nodes, edges };
    }

    function saveState() {
      const data = buildState();
      localStorage.setItem('workspaceState', JSON.stringify(data));
    }

    function restoreState(data) {
      // Clear existing
      qLines().forEach(l => l.remove());
      stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });

      // Reset counter
      idCounter = data?.idCounter ?? 1;

      // Rebuild nodes
      const byId = {};
      (data?.nodes || []).forEach(n => {
        let node;
        if (n.id === 'node-0') {
          node = mainNode;
        } else {
          node = document.createElement('div');
          node.className = 'node';
          node.dataset.id = n.id;
          stage.appendChild(node);
          enableDrag(node);
        }
        node.style.left = n.left;
        node.style.top = n.top;
        if (n.w) node.style.width  = n.w + 'px';
        if (n.h) node.style.height = n.h + 'px';
        const col = normalizeHex(n.color) || toHex(n.color) || '#CC0000';
        node.style.backgroundColor = col;
        node.innerHTML = '<span class="label"></span>';
        const labelEl = node.querySelector('.label');
        labelEl.textContent = n.text || '';
        if (n.fontFamily) labelEl.style.fontFamily = n.fontFamily;
        if (n.fontWeight) labelEl.style.fontWeight = n.fontWeight;
        if (n.fontStyle) labelEl.style.fontStyle = n.fontStyle;
        if (n.textDecoration) labelEl.style.textDecoration = n.textDecoration;
        if (n.maxFont) node.dataset.maxFont = String(n.maxFont);
        fitLabelToNode(node);
        if (!node.id) node.id = '';
        byId[n.id] = node;
      });

      // Ensure main exists if missing
      if (!byId['node-0']) {
        mainNode.dataset.id = 'node-0';
        mainNode.querySelector('.label').textContent = 'Cercle principal';
        byId['node-0'] = mainNode;
      }

      // Enable drag for main if not already
      enableDrag(mainNode);
    fitLabelToNode(mainNode);

      // Rebuild edges
      (data?.edges || []).forEach(e => {
        if (byId[e.from] && byId[e.to]) createLine(byId[e.from], byId[e.to]);
      });

      updateAllLines();
      saveState();
    }

    // --- Init
    enableDrag(mainNode);

    // Load saved state if any
    const saved = localStorage.getItem('workspaceState');
    if (saved) {
      try { restoreState(JSON.parse(saved)); } catch { /* ignore */ }
    } else {
      saveState();
    }
  </script>
</body>
</html>
