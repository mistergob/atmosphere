<!--
PLAN (pseudocode)
- Add a native <input type="color" id="colorPicker"> inside the context menu.
- When opening the menu, sync the picker with the selected node's color.
- On picker change/input, apply the color to the current node and persist state.
- Replace prompt-based color change: clicking "Modifier la couleur" focuses/triggers the color input.
- Store colors as normalized HEX (#RRGGBB) in localStorage; convert from computed rgb() when needed.
- When creating/restoring nodes, use HEX values to avoid rgb()/var() mismatches.
-->

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Espace de Travail ‚Äî saisie hex</title>
  <style>
    :root {
      --bg: #f5f6f8;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #cc0000;
      --ring: rgba(17,24,39,0.08);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      user-select: none;
      overflow: hidden;
    }

    /* Stage */
    .stage { position: relative; width: 100vw; height: 100vh; display: grid; place-items: center; }

    /* Lines canvas */
    svg#wires { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    /* Node (circle) */
    .node {
      position: absolute; width: 110px; height: 110px; border-radius: 9999px;
      background-color: var(--primary);
      color: #fff; display: flex; align-items: center; justify-content: center;
      font-weight: 700; text-align: center; padding: 10px; box-shadow: 0 8px 24px var(--ring);
      cursor: grab; transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease; will-change: transform, left, top;
    }
    .node:active { cursor: grabbing; }
    .node:hover { filter: brightness(1.05); }
    .node .label { pointer-events: none; line-height: 1.1; }

    /* Context menu */
    .menu {
      position: fixed; display: none; flex-direction: column; min-width: 260px;
      background: var(--card); border: 1px solid #e5e7eb; border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15); overflow: hidden; z-index: 50;
    }
    .menu button { appearance: none; background: transparent; border: 0; text-align: left; padding: 12px 14px; font-size: 14px; cursor: pointer; }
    .menu button:hover { background: #f3f4f6; }
    .menu .row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-top: 1px solid #e5e7eb; }
    .menu .row label { font-size: 12px; color: var(--muted); }
    .menu .row input[type="color"] { width: 36px; height: 28px; border: 1px solid #e5e7eb; border-radius: 6px; padding: 0; background: transparent; cursor: pointer; }

    /* Toolbar */
    .toolbar { position: fixed; right: 16px; top: 16px; display: flex; gap: 8px; background: var(--card); border: 1px solid #e5e7eb; border-radius: 14px; padding: 8px; box-shadow: 0 8px 24px var(--ring); z-index: 60; }
    .toolbar button { padding: 8px 12px; border: 0; border-radius: 10px; background: #111827; color: #fff; font-weight: 600; cursor: pointer; }
    .toolbar button.secondary { background: #4b5563; }
    .toolbar button.danger { background: #b91c1c; }

    /* Accessibility focus */
    .menu button:focus, .toolbar button:focus { outline: 3px solid #93c5fd; outline-offset: 2px; }
  </style>
</head>
<body>
  <div id="stage" class="stage" aria-label="Espace de travail">
    <svg id="wires" aria-hidden="true"></svg>
    <div id="main-node" class="node" data-id="node-0" style="left: calc(50% - 55px); top: calc(50% - 55px);">
      <span class="label">Cercle Principal</span>
    </div>
  </div>

  <!-- Context menu -->
  <div id="menu" class="menu" role="menu" aria-hidden="true">
    <button data-action="add">‚ûï Grand Cercle (m√™me taille)</button>
    <button data-action="addSmall">‚ûï Petit Cercle</button>
    <button data-action="color">üé® Modifier la couleur</button>
    <div class="row" aria-label="S√©lecteur de couleur">
      <label for="colorPicker">Couleur</label>
      <input id="colorPicker" type="color" value="#CC0000" />
      <button data-action="applyAll" title="Appliquer cette couleur √† tous les cercles">Appliquer √† tous</button>
    </div>
    <button data-action="rename">‚úèÔ∏è Renommer le cercle</button>
    <button data-action="delete">üóëÔ∏è Supprimer le cercle</button>
  </div>

  <!-- Quick actions -->
  <div class="toolbar" aria-label="Actions rapides">
    <button id="exportBtn">Exporter JSON</button>
    <button id="importBtn" class="secondary">Importer JSON</button>
    <button id="resetBtn" class="danger">R√©initialiser</button>
    <input id="fileInput" type="file" accept="application/json" style="display:none" />
  </div>

  <script>
    // --- State & Elements
    const stage = document.getElementById('stage');
    const svg = document.getElementById('wires');
    const menu = document.getElementById('menu');
    const mainNode = document.getElementById('main-node');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const colorPicker = document.getElementById('colorPicker');

    let currentNode = null;
    let idCounter = 1; // will be overridden by saved state if any

    // Tailles fixes pour deux types de cercles
    const BIG_SIZE = 110;  // Grand Cercle
    const SMALL_SIZE = 55; // Petit Cercle

    // --- Utilities
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
    const isHex = (s) => !!String(s).match(/^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/);

    function stageRect() { return stage.getBoundingClientRect(); }

    function getCenter(el) {
      const r = el.getBoundingClientRect();
      const s = stageRect();
      return { x: r.left - s.left + r.width / 2, y: r.top - s.top + r.height / 2 };
    }

    function qLines() { return svg.querySelectorAll('line'); }

    function updateLineEnds(line) {
      const from = document.querySelector(`[data-id="${line.dataset.from}"]`);
      const to = document.querySelector(`[data-id="${line.dataset.to}"]`);
      if (!from || !to) return;
      const c1 = getCenter(from);
      const c2 = getCenter(to);
      line.setAttribute('x1', c1.x); line.setAttribute('y1', c1.y);
      line.setAttribute('x2', c2.x); line.setAttribute('y2', c2.y);
    }

    function updateLinesFor(el) {
      const id = el.dataset.id;
      qLines().forEach(line => {
        if (line.dataset.from === id || line.dataset.to === id) updateLineEnds(line);
      });
    }

    function updateAllLines() { qLines().forEach(updateLineEnds); }

    function createLine(fromEl, toEl) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('stroke', '#111827');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-linecap', 'round');
      line.dataset.from = fromEl.dataset.id;
      line.dataset.to = toEl.dataset.id;
      svg.appendChild(line);
      updateLineEnds(line);
      return line;
    }

    function enableDrag(node) {
      if (node._dragEnabled) return; // avoid duplicate listeners
      let offsetX = 0, offsetY = 0;

      node.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return; // only left click
        currentNode = node;
        openMenu(null); // ensure menu closes while dragging
        node.setPointerCapture(e.pointerId);
        const rect = node.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        const onMove = (ev) => {
          const sr = stageRect();
          const newLeft = clamp(ev.clientX - sr.left - offsetX, 0, sr.width - rect.width);
          const newTop  = clamp(ev.clientY - sr.top - offsetY, 0, sr.height - rect.height);
          node.style.left = newLeft + 'px';
          node.style.top = newTop + 'px';
          updateLinesFor(node);
        };

        const onUp = () => {
          node.releasePointerCapture(e.pointerId);
          node.removeEventListener('pointermove', onMove);
          node.removeEventListener('pointerup', onUp);
          saveState();
        };

        node.addEventListener('pointermove', onMove);
        node.addEventListener('pointerup', onUp);
      });

      // Open custom menu on right-click + left-click
      node.addEventListener('contextmenu', (e) => { e.preventDefault(); openMenu(e, node); });
      node.addEventListener('click', (e) => { openMenu(e, node); });

      node._dragEnabled = true;
    }

    function addNodeNear(target) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();

      const baseW = BIG_SIZE;
      const baseH = BIG_SIZE;

      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - baseW);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - baseH);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = baseW + 'px';
      node.style.height = baseH + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Grand Cercle';
      node.appendChild(span);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      saveState();
      return node;
    }

    function addNodeNearScaled(target, scale = 0.5) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();
      const baseW = parseFloat(getComputedStyle(target).width) || target.offsetWidth || 110;
      const baseH = parseFloat(getComputedStyle(target).height) || target.offsetHeight || 110;
      const w = SMALL_SIZE;
      const h = SMALL_SIZE;

      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - w);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - h);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = w + 'px';
      node.style.height = h + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Petit Cercle';
      node.appendChild(span);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      saveState();
      return node;
    }

    function openMenu(event, node) {
      // Close if called with null
      if (!event) { menu.style.display = 'none'; return; }
      currentNode = node || currentNode;
      if (!currentNode) return;
      menu.style.display = 'flex';
      menu.setAttribute('aria-hidden', 'false');

      // sync color picker with the current node color
      const initialHex = toHex(getComputedStyle(currentNode).backgroundColor) || '#CC0000';
      colorPicker.value = initialHex;

      const mRect = menu.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      const x = Math.min(event.clientX, vw - mRect.width - 8);
      const y = Math.min(event.clientY, vh - mRect.height - 8);
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      event.stopPropagation();
    }

    function closeMenu() {
      menu.style.display = 'none';
      menu.setAttribute('aria-hidden', 'true');
    }

    // Menu actions
    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const action = btn.dataset.action;
      if (!currentNode) return;

      if (action === 'add') {
        addNodeNear(currentNode);
        closeMenu();
        return;
      }
      else if (action === 'addSmall') {
        addNodeNearScaled(currentNode, 0.5);
        const lbl = currentNode.querySelector('.label');
        if (lbl) lbl.textContent = 'Grand Cercle';
        closeMenu();
        return;
      }
      else if (action === 'color') {
        // Focus & open the native color picker
        colorPicker.focus();
        colorPicker.click();
        return; // keep menu open while picking
      }
      else if (action === 'applyAll') {
        const hex = normalizeHex(colorPicker.value) || '#CC0000';
        document.querySelectorAll('.node').forEach(n => { n.style.backgroundColor = hex; });
        saveState();
        return;
      }
      else if (action === 'rename') {
        const label = currentNode.querySelector('.label');
        const name = prompt('Entrez un nouveau nom :', label.textContent.trim());
        if (name) { label.textContent = name; saveState(); }
        closeMenu();
        return;
      }
      else if (action === 'delete') {
        if (currentNode.id === 'main-node' || currentNode.dataset.id === 'node-0') {
          alert('Le cercle principal ne peut pas √™tre supprim√©.');
        } else {
          qLines().forEach(line => {
            if (line.dataset.from === currentNode.dataset.id || line.dataset.to === currentNode.dataset.id) line.remove();
          });
          currentNode.remove();
          saveState();
        }
        closeMenu();
        return;
      }
    });

    // Color picker live update
    colorPicker.addEventListener('input', (e) => {
      if (!currentNode) return;
      const hex = normalizeHex(e.target.value);
      if (!hex) return;
      currentNode.style.backgroundColor = hex;
      saveState(); // persist as you pick
    });

    // Toolbar actions
    exportBtn.addEventListener('click', () => {
      const data = buildState();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'workspace.json'; a.click();
      URL.revokeObjectURL(url);
    });

    importBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const json = JSON.parse(text);
        restoreState(json);
      } catch (err) {
        alert('Fichier invalide.');
      } finally {
        fileInput.value = '';
      }
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('R√©initialiser l\'espace de travail ?')) {
        localStorage.removeItem('workspaceState');
        // Clear lines and nodes (except main)
        qLines().forEach(l => l.remove());
        stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });
        mainNode.style.left = 'calc(50% - 55px)';
        mainNode.style.top = 'calc(50% - 55px)';
        mainNode.querySelector('.label').textContent = 'Cercle Principal';
        mainNode.style.backgroundColor = 'var(--primary)';
        idCounter = 1;
        saveState();
        updateAllLines();
      }
    });

    // Click outside to close menu
    document.addEventListener('click', (e) => {
      if (!menu.contains(e.target)) closeMenu();
    });

    // Keep lines aligned on resize
    window.addEventListener('resize', updateAllLines);

    // --- Color helpers ---
    function normalizeHex(input) {
      if (!input) return null;
      let m = String(input).match(/^#?([0-9a-fA-F]{6})$/);
      if (m) return '#' + m[1].toUpperCase();
      m = String(input).match(/^#?([0-9a-fA-F]{3})$/);
      if (m) return '#' + m[1].split('').map(c => (c + c)).join('').toUpperCase();
      return null;
    }

    function toHex(input) {
      if (!input) return null;
      const hexMatch = String(input).trim().match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
      if (hexMatch) {
        const hex = hexMatch[1];
        if (hex.length === 3) return '#' + hex.split('').map(c => c + c).join('').toUpperCase();
        return '#' + hex.toUpperCase();
      }
      const m = String(input).match(/rgba?\(\s*([0-9.]+)[,\s]+([0-9.]+)[,\s]+([0-9.]+)/i);
      if (!m) return null;
      const [r,g,b] = [m[1], m[2], m[3]].map(v => Math.max(0, Math.min(255, Math.round(parseFloat(v)))));
      return '#' + [r,g,b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    // Persistence
    function buildState() {
      const nodes = Array.from(stage.querySelectorAll('.node')).map(n => ({
        id: n.dataset.id,
        left: n.style.left || '0px',
        top: n.style.top || '0px',
        w: parseFloat(getComputedStyle(n).width) || 110,
        h: parseFloat(getComputedStyle(n).height) || 110,
        text: n.querySelector('.label')?.textContent || '',
        color: toHex(n.style.backgroundColor || getComputedStyle(n).backgroundColor) || '#CC0000'
      }));
      const edges = Array.from(qLines()).map(l => ({ from: l.dataset.from, to: l.dataset.to }));
      return { idCounter, nodes, edges };
    }

    function saveState() {
      const data = buildState();
      localStorage.setItem('workspaceState', JSON.stringify(data));
    }

    function restoreState(data) {
      // Clear existing
      qLines().forEach(l => l.remove());
      stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });

      // Reset counter
      idCounter = data?.idCounter ?? 1;

      // Rebuild nodes
      const byId = {};
      (data?.nodes || []).forEach(n => {
        let node;
        if (n.id === 'node-0') {
          node = mainNode;
        } else {
          node = document.createElement('div');
          node.className = 'node';
          node.dataset.id = n.id;
          stage.appendChild(node);
          enableDrag(node);
        }
        node.style.left = n.left;
        node.style.top = n.top;
        if (n.w) node.style.width  = n.w + 'px';
        if (n.h) node.style.height = n.h + 'px';
        const col = normalizeHex(n.color) || toHex(n.color) || '#CC0000';
        node.style.backgroundColor = col;
        node.innerHTML = '<span class="label"></span>';
        node.querySelector('.label').textContent = n.text || '';
        if (!node.id) node.id = '';
        byId[n.id] = node;
      });

      // Ensure main exists if missing
      if (!byId['node-0']) {
        mainNode.dataset.id = 'node-0';
        mainNode.querySelector('.label').textContent = 'Cercle Principal';
        byId['node-0'] = mainNode;
      }

      // Enable drag for main if not already
      enableDrag(mainNode);

      // Rebuild edges
      (data?.edges || []).forEach(e => {
        if (byId[e.from] && byId[e.to]) createLine(byId[e.from], byId[e.to]);
      });

      updateAllLines();
      saveState();
    }

    // --- Init
    enableDrag(mainNode);

    // Load saved state if any
    const saved = localStorage.getItem('workspaceState');
    if (saved) {
      try { restoreState(JSON.parse(saved)); } catch { /* ignore */ }
    } else {
      saveState();
    }
  </script>
</body>
</html>
