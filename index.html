<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Espace de Travail ‚Äî saisie hex</title>
  <style>
    :root {
      --bg: #f5f6f8;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --primary: #cc0000;
      --ring: rgba(17,24,39,0.08);
      --sidebar-w: 260px;
      --sidebar2-w: 260px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      user-select: none;
      overflow: hidden;
    }

    /* Stage */
    .stage { position: relative; width: calc(100vw - var(--sidebar-w) - var(--sidebar2-w)); height: 100vh; margin-left: calc(var(--sidebar-w) + var(--sidebar2-w)); display: grid; place-items: center; }

    /* Lines canvas */
    svg#wires { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    /* Node (circle) */
    .node {
      position: absolute; width: 110px; height: 110px; border-radius: 9999px;
      background-color: var(--primary);
      color: #fff; display: flex; align-items: center; justify-content: center;
      font-weight: 700; text-align: center; padding: 10px; box-shadow: 0 8px 24px var(--ring);
      cursor: grab; transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease; will-change: transform, left, top;
    }
    .node:active { cursor: grabbing; }
    .node:hover { filter: brightness(1.05); }
    .node.selected { outline: 3px solid #2563eb; box-shadow: 0 0 0 6px rgba(37,99,235,0.25), 0 8px 24px var(--ring); }
    .node .label { pointer-events: none; line-height: 1.1; width: 100%; max-width: 100%; overflow: hidden; word-break: break-word; hyphens: auto; }

    /* Context menu */
    .menu {
      position: fixed; display: none; flex-direction: column; min-width: 260px;
      background: var(--card); border: 1px solid #e5e7eb; border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15); overflow: hidden; z-index: 50;
    }
    .menu button { appearance: none; background: transparent; border: 0; text-align: left; padding: 12px 14px; font-size: 14px; cursor: pointer; }
    .menu button:hover { background: #f3f4f6; }
    .menu .row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-top: 1px solid #e5e7eb; }
    .menu .row label { font-size: 12px; color: var(--muted); }
    .menu .row input[type="color"] { width: 36px; height: 28px; border: 1px solid #e5e7eb; border-radius: 6px; padding: 0; background: transparent; cursor: pointer; }
    .menu select, .menu input[type="number"] { height: 28px; border: 1px solid #e5e7eb; border-radius: 6px; padding: 0 8px; background: transparent; }
    .menu .toggle-group { display: flex; gap: 8px; }
    .menu .toggle { padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; }
    .menu .toggle[aria-pressed="true"] { background: #111827; color: #fff; }

    /* Toolbar */
    .toolbar { position: fixed; right: 16px; top: 16px; display: flex; gap: 8px; background: var(--card); border: 1px solid #e5e7eb; border-radius: 14px; padding: 8px; box-shadow: 0 8px 24px var(--ring); z-index: 60; }
    .toolbar button { padding: 8px 12px; border: 0; border-radius: 10px; background: #111827; color: #fff; font-weight: 600; cursor: pointer; }
    .toolbar button.secondary { background: #4b5563; }
    .toolbar button.danger { background: #b91c1c; }

    /* Sidebar */
    .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: var(--sidebar-w); background: var(--card); border-right: 1px solid #e5e7eb; box-shadow: 0 8px 24px var(--ring); padding: 12px; overflow: auto; z-index: 70; }
    .side-header { font-weight: 800; font-size: 14px; letter-spacing: .02em; margin: 4px 0 10px; text-transform: uppercase; color: var(--muted); }
    .sidebar2 { left: var(--sidebar-w); width: var(--sidebar2-w); }
    .side-item { width: 100%; text-align: left; padding: 10px 12px; border: 1px solid #e5e7eb; border-radius: 10px; background: #111827; color: #fff; font-weight: 700; cursor: pointer; margin-bottom: 8px; }
    .child-list { list-style: none; padding-left: 10px; margin: 6px 0 12px; }
    .child-list li { padding: 6px 8px; border-radius: 8px; border: 1px solid #e5e7eb; background: #fff; margin-bottom: 6px; font-size: 13px; cursor: pointer; }
    .child-list li:hover { background: #f3f4f6; }

    /* highlight pulse */
    @keyframes pulseNode { 0% { box-shadow: 0 0 0 0 rgba(17,24,39,.35); } 100% { box-shadow: 0 0 0 6px rgba(17,24,39,0); }}
    .node.pulse { animation: pulseNode 600ms ease-out 2; }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <aside id="sidebar" class="sidebar" aria-label="Navigation">
    <div class="side-header">Cercles principaux</div>
    <div id="principalList"></div>
  </aside>
  <!-- Sidebar droite : panneau d‚Äôactions -->
  <aside id="actions" class="sidebar sidebar2" aria-label="Actions du cercle">
    <div class="side-header">Actions du cercle</div>
    <div id="selectedInfo" style="font-size:12px;color:var(--muted);margin:0 0 8px;">Aucun cercle s√©lectionn√©</div>
    <button id="actAddPrincipal" class="side-item" type="button">‚ûï Cercle principal</button>
    <button id="actAddSecondary" class="side-item" type="button">‚ûï Cercle secondaire</button>
    <div class="row" aria-label="Couleur (panneau)">
      <label for="colorPicker2">Couleur</label>
      <input id="colorPicker2" type="color" value="#CC0000" />
    </div>
    <div class="row" aria-label="Police (panneau)">
      <label for="fontSelect2">Police</label>
      <select id="fontSelect2">
        <option value="system-ui">Syst√®me</option>
        <option value="Arial">Arial</option>
        <option value="Roboto">Roboto</option>
        <option value="Georgia">Georgia</option>
        <option value="'Times New Roman'">Times New Roman</option>
        <option value="'Courier New'">Courier New</option>
      </select>
    </div>
    <div class="row" aria-label="Taille max (panneau)">
      <label for="fontSizeMax2">Taille max</label>
      <input id="fontSizeMax2" type="number" min="6" max="72" step="1" value="32" />
    </div>
    <div class="row" aria-label="Style (panneau)">
      <label>Style</label>
      <div class="toggle-group">
        <button type="button" id="boldBtn2" class="toggle" aria-pressed="true">Gras</button>
        <button type="button" id="italicBtn2" class="toggle" aria-pressed="false">Italique</button>
        <button type="button" id="underlineBtn2" class="toggle" aria-pressed="false">Soulign√©</button>
      </div>
    </div>
    <button id="actCenter" class="side-item" type="button">üéØ Centrer sur le cercle</button>
    <button id="actRename" class="side-item" type="button">‚úèÔ∏è Renommer le cercle</button>
    <button id="actDelete" class="side-item" type="button" style="background:#b91c1c">üóëÔ∏è Supprimer le cercle</button>
  </aside>

  <div id="stage" class="stage" aria-label="Espace de travail">
    <svg id="wires" aria-hidden="true"></svg>
    <div id="main-node" class="node" data-id="node-0" style="left: calc(50% - 55px); top: calc(50% - 55px);">
      <span class="label">Cercle principal</span>
    </div>
  </div>

  <!-- Menu contextuel (clic droit uniquement) -->
  <div id="menu" class="menu" role="menu" aria-hidden="true">
    <button data-action="add">‚ûï Cercle principal</button>
    <button data-action="addSmall">‚ûï Cercle secondaire</button>
    <button data-action="color">üé® Modifier la couleur</button>
    <div class="row" aria-label="S√©lecteur de couleur">
      <label for="colorPicker">Couleur</label>
      <input id="colorPicker" type="color" value="#CC0000" />
    </div>
    <div class="row" aria-label="Police">
      <label for="fontSelect">Police</label>
      <select id="fontSelect">
        <option value="system-ui">Syst√®me</option>
        <option value="Arial">Arial</option>
        <option value="Roboto">Roboto</option>
        <option value="Georgia">Georgia</option>
        <option value="'Times New Roman'">Times New Roman</option>
        <option value="'Courier New'">Courier New</option>
      </select>
    </div>
    <div class="row" aria-label="Taille de police">
      <label for="fontSizeMax">Taille max</label>
      <input id="fontSizeMax" type="number" min="6" max="72" step="1" value="32" />
    </div>
    <div class="row" aria-label="Style de texte">
      <label>Style</label>
      <div class="toggle-group">
        <button type="button" id="boldBtn" class="toggle" aria-pressed="true">Gras</button>
        <button type="button" id="italicBtn" class="toggle" aria-pressed="false">Italique</button>
        <button type="button" id="underlineBtn" class="toggle" aria-pressed="false">Soulign√©</button>
      </div>
    </div>
    <button data-action="rename">‚úèÔ∏è Renommer le cercle</button>
    <button data-action="delete">üóëÔ∏è Supprimer le cercle</button>
  </div>

  <!-- Quick actions -->
  <div class="toolbar" aria-label="Actions rapides">
    <button id="exportBtn">Exporter JSON</button>
    <button id="importBtn" class="secondary">Importer JSON</button>
    <button id="resetBtn" class="danger">R√©initialiser</button>
    <input id="fileInput" type="file" accept="application/json" style="display:none" />
  </div>

  <script>
    // --- State & Elements
    const stage = document.getElementById('stage');
    const svg = document.getElementById('wires');
    const menu = document.getElementById('menu');
    const mainNode = document.getElementById('main-node');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const colorPicker = document.getElementById('colorPicker');
    const fontSelect = document.getElementById('fontSelect');
    const fontSizeMax = document.getElementById('fontSizeMax');
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    const underlineBtn = document.getElementById('underlineBtn');
    const principalList = document.getElementById('principalList');
    // Panneau d‚Äôactions (droite)
    const actionsPanel = document.getElementById('actions');
    const selectedInfo = document.getElementById('selectedInfo');
    const actAddPrincipal = document.getElementById('actAddPrincipal');
    const actAddSecondary = document.getElementById('actAddSecondary');
    const actCenter = document.getElementById('actCenter');
    const actRename = document.getElementById('actRename');
    const actDelete = document.getElementById('actDelete');
    const colorPicker2 = document.getElementById('colorPicker2');
    const fontSelect2 = document.getElementById('fontSelect2');
    const fontSizeMax2 = document.getElementById('fontSizeMax2');
    const boldBtn2 = document.getElementById('boldBtn2');
    const italicBtn2 = document.getElementById('italicBtn2');
    const underlineBtn2 = document.getElementById('underlineBtn2');

    let currentNode = null;
    let idCounter = 1; // will be overridden by saved state if any

    // Tailles fixes pour deux types de cercles
    const BIG_SIZE = 110;  // Cercle principal
    const SMALL_SIZE = 55; // Cercle secondaire

    // --- Utilities
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

    function stageRect() { return stage.getBoundingClientRect(); }
    function getCenter(el) { const r = el.getBoundingClientRect(); const s = stageRect(); return { x: r.left - s.left + r.width/2, y: r.top - s.top + r.height/2 }; }
    function qLines() { return svg.querySelectorAll('line'); }

    function updateLineEnds(line) {
      const from = document.querySelector(`[data-id="${line.dataset.from}"]`);
      const to = document.querySelector(`[data-id="${line.dataset.to}"]`);
      if (!from || !to) return;
      const c1 = getCenter(from);
      const c2 = getCenter(to);
      line.setAttribute('x1', c1.x); line.setAttribute('y1', c1.y);
      line.setAttribute('x2', c2.x); line.setAttribute('y2', c2.y);
    }
    function updateLinesFor(el) { const id = el.dataset.id; qLines().forEach(line => { if (line.dataset.from === id || line.dataset.to === id) updateLineEnds(line); }); }
    function updateAllLines() { qLines().forEach(updateLineEnds); }

    function createLine(fromEl, toEl) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('stroke', '#111827');
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-linecap', 'round');
      line.dataset.from = fromEl.dataset.id;
      line.dataset.to = toEl.dataset.id;
      svg.appendChild(line);
      updateLineEnds(line);
      return line;
    }

    // --- Text autosize helpers ---
    function fitLabelToNode(node) {
      const label = node.querySelector('.label');
      if (!label) return;
      label.style.width = '100%';
      label.style.maxWidth = '100%';
      label.style.whiteSpace = 'normal';
      label.style.overflow = 'hidden';
      label.style.wordBreak = 'break-word';

      const cs = getComputedStyle(node);
      const padX = (parseFloat(cs.paddingLeft) || 0) + (parseFloat(cs.paddingRight) || 0);
      const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
      const contentW = Math.max(0, node.clientWidth - padX);
      const contentH = Math.max(0, node.clientHeight - padY);

      const cap = parseFloat(node.dataset.maxFont);
      let low = 6;
      let high = Math.max(6, Math.floor(Math.min(contentH, Number.isFinite(cap) ? cap : contentH)));
      let best = low;

      if (!label.textContent || !label.textContent.trim()) {
        label.style.fontSize = Math.min(16, high) + 'px';
        return;
      }
      for (let i = 0; i < 12 && low <= high; i++) {
        const mid = Math.floor((low + high) / 2);
        label.style.fontSize = mid + 'px';
        const fits = label.scrollWidth <= contentW && label.scrollHeight <= contentH;
        if (fits) { best = mid; low = mid + 1; } else { high = mid - 1; }
      }
      label.style.fontSize = best + 'px';
    }
    function fitAllLabels() { document.querySelectorAll('.node').forEach(fitLabelToNode); }

    // --- Selection helpers
    function enableActionPanel(enabled){
      const ctrls = actionsPanel?.querySelectorAll('button,select,input');
      ctrls?.forEach(el=>{ el.disabled = !enabled; if(!enabled && el.classList.contains('toggle')) el.setAttribute('aria-pressed','false'); });
      selectedInfo.textContent = enabled && currentNode ? (currentNode.querySelector('.label')?.textContent || currentNode.dataset.id) : 'Aucun cercle s√©lectionn√©';
    }
    function syncActionPanel(){
      if(!currentNode){ enableActionPanel(false); return; }
      enableActionPanel(true);
      const hex = toHex(getComputedStyle(currentNode).backgroundColor) || '#CC0000';
      colorPicker.value = hex; colorPicker2.value = hex;
      const labelEl = currentNode.querySelector('.label');
      const famInline = labelEl.style.fontFamily;
      const fam = famInline && Array.from(fontSelect.options).some(o=>o.value===famInline) ? famInline : 'system-ui';
      fontSelect.value = fam; fontSelect2.value = fam;
      const cap = currentNode.dataset.maxFont || '32';
      fontSizeMax.value = cap; fontSizeMax2.value = cap;
      const cs = getComputedStyle(labelEl);
      const fw = parseInt(cs.fontWeight,10);
      const isBold = (fw >= 600) || cs.fontWeight === 'bold';
      const isItalic = cs.fontStyle === 'italic';
      const isUnderline = (cs.textDecorationLine || cs.textDecoration || '').includes('underline');
      [boldBtn,boldBtn2].forEach(b=>b.setAttribute('aria-pressed', isBold?'true':'false'));
      [italicBtn,italicBtn2].forEach(b=>b.setAttribute('aria-pressed', isItalic?'true':'false'));
      [underlineBtn,underlineBtn2].forEach(b=>b.setAttribute('aria-pressed', isUnderline?'true':'false'));
      selectedInfo.textContent = labelEl.textContent || currentNode.dataset.id;
    }
    function setCurrentNode(node){
      document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
      currentNode = node || null;
      if(currentNode){ currentNode.classList.add('selected'); }
      syncActionPanel();
    }
    function centerOnCurrent(){
      if(!currentNode) return;
      const sr = stageRect();
      const rect = currentNode.getBoundingClientRect();
      const left = Math.max(0, Math.min(sr.width - rect.width, (sr.width - rect.width)/2));
      const top  = Math.max(0, Math.min(sr.height - rect.height, (sr.height - rect.height)/2));
      currentNode.style.left = left + 'px';
      currentNode.style.top = top + 'px';
      updateLinesFor(currentNode);
      saveState();
      currentNode.classList.add('pulse'); setTimeout(()=>currentNode.classList.remove('pulse'),800);
    }

    function enableDrag(node) {
      if (node._dragEnabled) return;
      let offsetX = 0, offsetY = 0;

      node.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return; // only left click
        setCurrentNode(node);
        openMenu(null); // close context menu during drag
        node.setPointerCapture(e.pointerId);
        const rect = node.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        const onMove = (ev) => {
          const sr = stageRect();
          const newLeft = clamp(ev.clientX - sr.left - offsetX, 0, sr.width - rect.width);
          const newTop  = clamp(ev.clientY - sr.top - offsetY, 0, sr.height - rect.height);
          node.style.left = newLeft + 'px';
          node.style.top = newTop + 'px';
          updateLinesFor(node);
        };
        const onUp = () => {
          node.releasePointerCapture(e.pointerId);
          node.removeEventListener('pointermove', onMove);
          node.removeEventListener('pointerup', onUp);
          saveState();
        };
        node.addEventListener('pointermove', onMove);
        node.addEventListener('pointerup', onUp);
      });

      // Clic droit uniquement pour ouvrir le menu
      node.addEventListener('contextmenu', (e) => { e.preventDefault(); openMenu(e, node); });

      node._dragEnabled = true;
    }

    function addNodeNear(target) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();
      const baseW = BIG_SIZE, baseH = BIG_SIZE;
      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - baseW);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - baseH);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = baseW + 'px';
      node.style.height = baseH + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Cercle principal';
      node.appendChild(span);
      fitLabelToNode(node);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      setCurrentNode(node);
      saveState();
      return node;
    }

    function addNodeNearScaled(target) {
      const rect = target.getBoundingClientRect();
      const s = stageRect();
      const w = SMALL_SIZE, h = SMALL_SIZE;
      const baseW = parseFloat(getComputedStyle(target).width) || 110;
      const baseH = parseFloat(getComputedStyle(target).height) || 110;

      const left = clamp((rect.left - s.left) + baseW + 30, 0, s.width - w);
      const top  = clamp((rect.top  - s.top)  + baseH + 30, 0, s.height - h);

      const node = document.createElement('div');
      node.className = 'node';
      node.dataset.id = `node-${idCounter++}`;
      node.style.left = left + 'px';
      node.style.top = top + 'px';
      node.style.width = w + 'px';
      node.style.height = h + 'px';
      node.style.backgroundColor = toHex(getComputedStyle(target).backgroundColor) || '#CC0000';

      const span = document.createElement('span');
      span.className = 'label';
      span.textContent = 'Cercle secondaire';
      node.appendChild(span);
      fitLabelToNode(node);

      stage.appendChild(node);
      enableDrag(node);
      createLine(target, node);
      setCurrentNode(node);
      saveState();
      return node;
    }

    function openMenu(event, node) {
      // Close if called with null
      if (!event) { menu.style.display = 'none'; return; }
      if (node) setCurrentNode(node); else if (!currentNode) return;

      menu.style.display = 'flex';
      menu.setAttribute('aria-hidden', 'false');

      // sync menu controls with current node
      const initialHex = toHex(getComputedStyle(currentNode).backgroundColor) || '#CC0000';
      colorPicker.value = initialHex;

      const labelEl = currentNode.querySelector('.label');
      const famInline = labelEl.style.fontFamily;
      const famOpt = famInline && Array.from(fontSelect.options).some(o => o.value === famInline) ? famInline : 'system-ui';
      fontSelect.value = famOpt;
      fontSizeMax.value = currentNode.dataset.maxFont || '32';

      const csLabel = getComputedStyle(labelEl);
      const fw = parseInt(csLabel.fontWeight, 10);
      const isBold = (fw >= 600) || csLabel.fontWeight === 'bold';
      const isItalic = csLabel.fontStyle === 'italic';
      const isUnderline = (csLabel.textDecorationLine || csLabel.textDecoration || '').includes('underline');
      boldBtn.setAttribute('aria-pressed', isBold ? 'true' : 'false');
      italicBtn.setAttribute('aria-pressed', isItalic ? 'true' : 'false');
      underlineBtn.setAttribute('aria-pressed', isUnderline ? 'true' : 'false');

      const mRect = menu.getBoundingClientRect();
      const vw = window.innerWidth, vh = window.innerHeight;
      const x = Math.min(event.clientX, vw - mRect.width - 8);
      const y = Math.min(event.clientY, vh - mRect.height - 8);
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      event.stopPropagation();
    }
    function closeMenu() { menu.style.display = 'none'; menu.setAttribute('aria-hidden', 'true'); }

    // Menu actions
    menu.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn || !currentNode) return;
      const action = btn.dataset.action;

      if (action === 'add') {
        addNodeNear(currentNode); closeMenu(); return;
      }
      if (action === 'addSmall') {
        addNodeNearScaled(currentNode); const lbl = currentNode.querySelector('.label'); if (lbl) lbl.textContent = 'Cercle principal';
        closeMenu(); return;
      }
      if (action === 'color') { colorPicker.focus(); colorPicker.click(); return; }

      if (action === 'rename') {
        const label = currentNode.querySelector('.label');
        const name = prompt('Entrez un nouveau nom :', label.textContent.trim());
        if (name) { label.textContent = name; fitLabelToNode(currentNode); saveState(); }
        closeMenu(); return;
      }
      if (action === 'delete') {
        if (currentNode.id === 'main-node' || currentNode.dataset.id === 'node-0') {
          alert('Le cercle principal ne peut pas √™tre supprim√©.');
        } else {
          qLines().forEach(line => { if (line.dataset.from === currentNode.dataset.id || line.dataset.to === currentNode.dataset.id) line.remove(); });
          currentNode.remove();
          document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
          currentNode = null; enableActionPanel(false);
          saveState();
        }
        closeMenu(); return;
      }
    });

    // Couleur
    colorPicker.addEventListener('input', (e) => {
      if (!currentNode) return;
      const hex = normalizeHex(e.target.value); if (!hex) return;
      currentNode.style.backgroundColor = hex; colorPicker2.value = hex; saveState();
    });
    colorPicker2.addEventListener('input', (e) => {
      if (!currentNode) return;
      const hex = normalizeHex(e.target.value); if (!hex) return;
      currentNode.style.backgroundColor = hex; colorPicker.value = hex; saveState();
    });

    // Police
    function setFamily(val){ if(!currentNode) return; const label=currentNode.querySelector('.label'); label.style.fontFamily=val; fitLabelToNode(currentNode); saveState(); }
    fontSelect.addEventListener('change', (e)=>{ setFamily(e.target.value); fontSelect2.value=e.target.value; });
    fontSelect2.addEventListener('change', (e)=>{ setFamily(e.target.value); fontSelect.value=e.target.value; });

    // Taille max
    function setMax(v){
      if(!currentNode) return;
      const min=6, max=72, val=Math.max(min, Math.min(max, parseFloat(v)||min));
      currentNode.dataset.maxFont = String(val);
      fontSizeMax.value = String(val);
      fontSizeMax2.value = String(val);
      fitLabelToNode(currentNode); saveState();
    }
    fontSizeMax.addEventListener('input', (e)=> setMax(e.target.value));
    fontSizeMax2.addEventListener('input', (e)=> setMax(e.target.value));

    // Styles
    function toggle(btnA, btnB, apply){
      if(!currentNode) return;
      const pressed = btnA.getAttribute('aria-pressed') === 'true' ? 'false' : 'true';
      btnA.setAttribute('aria-pressed', pressed); btnB.setAttribute('aria-pressed', pressed);
      apply(pressed === 'true'); fitLabelToNode(currentNode); saveState();
    }
    boldBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(boldBtn,boldBtn2,(on)=> currentNode.querySelector('.label').style.fontWeight = on?'700':'400'); });
    boldBtn2.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(boldBtn2,boldBtn,(on)=> currentNode.querySelector('.label').style.fontWeight = on?'700':'400'); });
    italicBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(italicBtn,italicBtn2,(on)=> currentNode.querySelector('.label').style.fontStyle = on?'italic':'normal'); });
    italicBtn2.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(italicBtn2,italicBtn,(on)=> currentNode.querySelector('.label').style.fontStyle = on?'italic':'normal'); });
    underlineBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(underlineBtn,underlineBtn2,(on)=> currentNode.querySelector('.label').style.textDecoration = on?'underline':'none'); });
    underlineBtn2.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(underlineBtn2,underlineBtn,(on)=> currentNode.querySelector('.label').style.textDecoration = on?'underline':'none'); });

    // Actions panneau droit
    actAddPrincipal.addEventListener('click', ()=>{ if(!currentNode) return; addNodeNear(currentNode); });
    actAddSecondary.addEventListener('click', ()=>{ if(!currentNode) return; addNodeNearScaled(currentNode); });
    actCenter.addEventListener('click', ()=> centerOnCurrent());
    actRename.addEventListener('click', ()=>{ if(!currentNode) return; const label=currentNode.querySelector('.label'); const name = prompt('Entrez un nouveau nom :', label.textContent.trim()); if(name){ label.textContent=name; fitLabelToNode(currentNode); saveState(); syncActionPanel(); } });
    actDelete.addEventListener('click', ()=>{ if(!currentNode) return; if (currentNode.id === 'main-node' || currentNode.dataset.id === 'node-0') { alert('Le cercle principal ne peut pas √™tre supprim√©.'); return; } qLines().forEach(line => { if (line.dataset.from === currentNode.dataset.id || line.dataset.to === currentNode.dataset.id) line.remove(); }); currentNode.remove(); document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected')); currentNode = null; enableActionPanel(false); saveState(); });

    // Sidebar gauche (principaux + secondaires)
    const approxEq = (a,b,eps=0.5)=>Math.abs(a-b)<=eps;
    function isPrincipalNode(n){ const w = parseFloat(getComputedStyle(n).width)||0; return approxEq(w, BIG_SIZE); }
    function isSecondaryNode(n){ const w = parseFloat(getComputedStyle(n).width)||0; return approxEq(w, SMALL_SIZE); }
    function getNodeById(id){ return document.querySelector(`[data-id="${id}"]`); }
    function neighborsOf(id){
      const res = []; qLines().forEach(l=>{ if(l.dataset.from===id) res.push(l.dataset.to); else if(l.dataset.to===id) res.push(l.dataset.from); });
      return Array.from(new Set(res));
    }
    function populateChildren(principalId, container){
      container.innerHTML='';
      const seconds = neighborsOf(principalId).map(getNodeById).filter(Boolean).filter(isSecondaryNode);
      if(seconds.length===0){ const li=document.createElement('li'); li.textContent='Aucun cercle secondaire'; li.style.color='#6b7280'; li.style.borderStyle='dashed'; container.appendChild(li); return; }
      seconds.forEach(n=>{
        const li=document.createElement('li');
        li.textContent = (n.querySelector('.label')?.textContent || n.dataset.id);
        li.addEventListener('click',()=>{ setCurrentNode(n); n.classList.add('pulse'); setTimeout(()=>n.classList.remove('pulse'),800); });
        container.appendChild(li);
      });
    }
    function refreshSidebar(){
      if(!principalList) return;
      principalList.innerHTML='';
      const principals = Array.from(document.querySelectorAll('.node')).filter(isPrincipalNode);
      principals.forEach(n=>{
        const wrap=document.createElement('div');
        const btn=document.createElement('button'); btn.className='side-item'; btn.type='button';
        btn.textContent=n.querySelector('.label')?.textContent||n.dataset.id; btn.dataset.pid=n.dataset.id;
        const ul=document.createElement('ul'); ul.className='child-list'; ul.style.display='none';
        btn.addEventListener('click',()=>{ setCurrentNode(n); if(ul.style.display==='none'){ populateChildren(n.dataset.id, ul); ul.style.display='block'; } else { ul.style.display='none'; } });
        wrap.appendChild(btn); wrap.appendChild(ul); principalList.appendChild(wrap);
      });
    }

    // Export/Import/Reset
    exportBtn.addEventListener('click', () => {
      const data = buildState();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'workspace.json'; a.click();
      URL.revokeObjectURL(url);
    });
    importBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files?.[0]; if (!file) return;
      try { const text = await file.text(); restoreState(JSON.parse(text)); }
      catch { alert('Fichier invalide.'); }
      finally { fileInput.value = ''; }
    });
    resetBtn.addEventListener('click', () => {
      if (confirm('R√©initialiser l\'espace de travail ?')) {
        localStorage.removeItem('workspaceState');
        qLines().forEach(l => l.remove());
        stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });
        mainNode.style.left = 'calc(50% - 55px)';
        mainNode.style.top = 'calc(50% - 55px)';
        mainNode.querySelector('.label').textContent = 'Cercle principal';
        fitLabelToNode(mainNode);
        mainNode.style.backgroundColor = 'var(--primary)';
        document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
        currentNode = null; enableActionPanel(false);
        idCounter = 1;
        saveState();
        updateAllLines();
      }
    });

    // Click outside to close menu
    document.addEventListener('click', (e) => { if (!menu.contains(e.target)) closeMenu(); });
    // Deselect when clicking empty stage area
    stage.addEventListener('mousedown', (e) => {
      if (!e.target.closest('.node') && !menu.contains(e.target) && !actionsPanel.contains(e.target) && !document.getElementById('sidebar').contains(e.target)) {
        document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected'));
        currentNode = null; enableActionPanel(false);
      }
    });

    // Keep lines aligned on resize
    window.addEventListener('resize', () => { updateAllLines(); fitAllLabels(); });

    // --- Color helpers ---
    function normalizeHex(input) {
      if (!input) return null;
      let m = String(input).match(/^#?([0-9a-fA-F]{6})$/);
      if (m) return '#' + m[1].toUpperCase();
      m = String(input).match(/^#?([0-9a-fA-F]{3})$/);
      if (m) return '#' + m[1].split('').map(c => (c + c)).join('').toUpperCase();
      return null;
    }
    function toHex(input) {
      if (!input) return null;
      const hexMatch = String(input).trim().match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
      if (hexMatch) {
        const hex = hexMatch[1];
        if (hex.length === 3) return '#' + hex.split('').map(c => c + c).join('').toUpperCase();
        return '#' + hex.toUpperCase();
      }
      const m = String(input).match(/rgba?\(\s*([0-9.]+)[,\s]+([0-9.]+)[,\s]+([0-9.]+)/i);
      if (!m) return null;
      const [r,g,b] = [m[1], m[2], m[3]].map(v => Math.max(0, Math.min(255, Math.round(parseFloat(v)))));
      return '#' + [r,g,b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    // Persistence
    function buildState() {
      const nodes = Array.from(stage.querySelectorAll('.node')).map(n => ({
        id: n.dataset.id,
        left: n.style.left || '0px',
        top: n.style.top || '0px',
        w: parseFloat(getComputedStyle(n).width) || 110,
        h: parseFloat(getComputedStyle(n).height) || 110,
        text: n.querySelector('.label')?.textContent || '',
        color: toHex(n.style.backgroundColor || getComputedStyle(n).backgroundColor) || '#CC0000',
        fontFamily: n.querySelector('.label')?.style.fontFamily || '',
        fontWeight: n.querySelector('.label')?.style.fontWeight || '',
        fontStyle: n.querySelector('.label')?.style.fontStyle || '',
        textDecoration: n.querySelector('.label')?.style.textDecoration || '',
        maxFont: n.dataset.maxFont ? parseFloat(n.dataset.maxFont) : null
      }));
      const edges = Array.from(qLines()).map(l => ({ from: l.dataset.from, to: l.dataset.to }));
      return { idCounter, nodes, edges };
    }
    function saveState() {
      const data = buildState();
      localStorage.setItem('workspaceState', JSON.stringify(data));
      refreshSidebar();
    }
    function restoreState(data) {
      qLines().forEach(l => l.remove());
      stage.querySelectorAll('.node').forEach(n => { if (n !== mainNode) n.remove(); });

      idCounter = data?.idCounter ?? 1;

      const byId = {};
      (data?.nodes || []).forEach(n => {
        let node;
        if (n.id === 'node-0') { node = mainNode; }
        else {
          node = document.createElement('div');
          node.className = 'node';
          node.dataset.id = n.id;
          stage.appendChild(node);
          enableDrag(node);
        }
        node.style.left = n.left;
        node.style.top = n.top;
        if (n.w) node.style.width  = n.w + 'px';
        if (n.h) node.style.height = n.h + 'px';
        const col = normalizeHex(n.color) || toHex(n.color) || '#CC0000';
        node.style.backgroundColor = col;
        node.innerHTML = '<span class="label"></span>';
        const labelEl = node.querySelector('.label');
        labelEl.textContent = n.text || '';
        if (n.fontFamily) labelEl.style.fontFamily = n.fontFamily;
        if (n.fontWeight) labelEl.style.fontWeight = n.fontWeight;
        if (n.fontStyle) labelEl.style.fontStyle = n.fontStyle;
        if (n.textDecoration) labelEl.style.textDecoration = n.textDecoration;
        if (n.maxFont) node.dataset.maxFont = String(n.maxFont);
        fitLabelToNode(node);
        byId[n.id] = node;
      });

      if (!byId['node-0']) { mainNode.dataset.id = 'node-0'; mainNode.querySelector('.label').textContent = 'Cercle principal'; byId['node-0'] = mainNode; }

      enableDrag(mainNode);
      fitLabelToNode(mainNode);

      (data?.edges || []).forEach(e => { if (byId[e.from] && byId[e.to]) createLine(byId[e.from], byId[e.to]); });

      updateAllLines();
      refreshSidebar();
      saveState();
    }

    // --- Init
    enableDrag(mainNode);
    refreshSidebar();
    enableActionPanel(false);

    // Load saved state if any
    const saved = localStorage.getItem('workspaceState');
    if (saved) { try { restoreState(JSON.parse(saved)); } catch { /* ignore */ } } else { saveState(); }
  </script>
</body>
</html>
